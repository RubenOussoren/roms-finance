---
description: Investment projection patterns - adaptive projections, Monte Carlo, PAG compliance
globs:
  - "**/{models,calculators,jobs}/**/*.rb"
  - "app/components/projection*.rb"
alwaysApply: false
---

# Investment Projection Patterns

Adaptive investment projections with Monte Carlo confidence bands, PAG 2025 compliance,
and milestone tracking. Calculators are pure (no caching, no side effects).
Caching lives in `ProjectionsController`.

## Architecture Overview

```
Calculators (pure math, app/calculators/):
  ProjectionCalculator     — single-account compound growth + Monte Carlo
  FamilyProjectionCalculator — family net worth aggregation + correlation matrix
  MilestoneCalculator      — time-to-goal + probability estimation

Shared module:
  PercentileZScores        — z-score constants + drift-corrected percentile bands

Models:
  ProjectionStandard       — PAG 2025 canonical return assumptions
  ProjectionAssumption     — per-account or family-default customizable assumptions
  Account::ProjectionFacade — projection/milestone facade for Account (replaces Projectable concern)
  Account::Projection      — stored projection records (DB checkpoints)
  Milestone                — financial goal tracking

Concerns:
  PagCompliant             — PAG 2025 compliance checks and warnings
```

---

## ProjectionCalculator

Pure calculator for single-account compound growth projections.

```ruby
# app/calculators/projection_calculator.rb
class ProjectionCalculator
  include PercentileZScores

  def initialize(principal:, rate:, contribution: 0, currency: "CAD")

  # Core methods
  def future_value_at_month(month)     # FV = P(1+r)^n + PMT*((1+r)^n - 1)/r
  def project(months:)                 # Array of {month, date, balance, cumulative_contribution, growth}
  def months_to_target(target:)        # Binary search, returns nil if unreachable
  def years_to_target(target:)         # months_to_target / 12
  def required_contribution(target:, months:)
  def real_future_value_at_month(month, inflation_rate:)

  # Confidence bands
  def project_with_percentiles(months:, volatility:, simulations: 1000)  # Monte Carlo
  def project_with_analytical_bands(months:, volatility:)                # Deterministic + sqrt(t) bands
end
```

Investment growth uses monthly compounding (`rate / 12`).
Canadian mortgages use semi-annual compounding — see `debt-optimization.mdc`.

### Monte Carlo Implementation

Pure Ruby Box-Muller transform with `Float::EPSILON` guard:

```ruby
def gaussian_random
  u1 = [rand, Float::EPSILON].max  # prevents log(0) = -Infinity
  u2 = rand
  Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math::PI * u2)
end
```

Each simulation path: `balance = balance * (1 + monthly_rate + monthly_vol * gaussian_random) + contribution`

---

## PercentileZScores Module

Shared z-score constants and drift-corrected percentile calculation.

```ruby
# app/calculators/percentile_z_scores.rb
module PercentileZScores
  Z_P10 = -1.28
  Z_P25 = -0.67
  Z_P75 =  0.67
  Z_P90 =  1.28

  def calculate_percentiles_for_value(value, sigma)
    drift_correction = Math.exp(-sigma**2 / 2.0)
    # p50 uses drift correction: median = value * exp(-sigma^2/2)
    # This ensures p50 shows the true median, not the mean
    # (mean > median for log-normal distributions)
    {
      p10: value * Math.exp(Z_P10 * sigma),
      p25: value * Math.exp(Z_P25 * sigma),
      p50: value * drift_correction,
      p75: value * Math.exp(Z_P75 * sigma),
      p90: value * Math.exp(Z_P90 * sigma)
    }
  end
end
```

Handles negative values (debts) by flipping signs. Included by `ProjectionCalculator`,
`FamilyProjectionCalculator`, and `MilestoneCalculator`.

---

## FamilyProjectionCalculator

Aggregates projections across all family accounts for net worth trajectory.

```ruby
# app/calculators/family_projection_calculator.rb
class FamilyProjectionCalculator
  include PercentileZScores

  DEFAULT_SAVINGS_RATE = 0.02
  SAME_CLASS_CORRELATION = 0.8   # equity-equity
  CROSS_CLASS_CORRELATION = 0.3  # equity-bonds

  def initialize(family)
  def project(years:)        # Returns {historical, projections, currency, today, summary, currency_warnings}
  def summary_metrics        # Quick {current_net_worth, total_assets, total_liabilities, currency}
end
```

### Portfolio Variance with Correlation Matrix

```ruby
# Var(portfolio) = sum_i(sum_j(w_i * w_j * sigma_i * sigma_j * rho_ij))
def aggregate_volatility(asset_accounts)
  # Builds weight/volatility/asset_class arrays from accounts
  # rho = 1.0 for self, SAME_CLASS_CORRELATION for same class, CROSS_CLASS_CORRELATION for cross
  # Returns sqrt(variance), defaults to 0.15 if empty
end
```

Asset class mapping: `Investment`/`Crypto` = `:equity`, `Depository` = `:fixed_income`.

### Per-Account Assumption Caching

```ruby
def assumption_for(account)
  @assumption_cache ||= {}
  @assumption_cache[account.id] ||= ProjectionAssumption.for_account(account)
end
```

Prevents N+1 queries. `aggregate_volatility` reuses this cache.

### Currency Mismatch Warnings

If any account uses a non-family currency, a warning is surfaced in the projection result:
`currency_warnings` key in the returned hash.

---

## MilestoneCalculator

Time-to-goal calculator supporting both growth milestones and debt reduction milestones.

```ruby
# app/calculators/milestone_calculator.rb
class MilestoneCalculator
  include PercentileZScores

  def initialize(current_balance:, assumption:, currency: "CAD", target_type: "reach")
  def time_to_target(target:)          # Delegates to time_to_grow_to or time_to_reduce_to
  def required_contribution(target:, target_date:)
  def analyze_standard_milestones      # All standard milestones with progress
  def suggest_scaled_milestones(max_suggestions: 5)
  def next_achievable_milestone
  def milestone_probability(target:, months:, simulations: 1000)
  def contribution_sensitivity(target:)  # 0x/0.5x/1x/1.5x/2x scenarios
end
```

### Log-Normal CDF Probability Estimation

Smooth extrapolation instead of hard-clamped bounds:

```ruby
def estimate_probability(target:, values:, percentiles:)
  # Fit log-normal: mu = log(p50), sigma = (log(p90) - log(p10)) / (2 * Z_P90)
  # Then: z = (log(target) - mu) / sigma
  # probability = (1 - normal_cdf(z)) * 100
  # Clamped to 0.5..99.5
end
```

### 30-Day Month Approximation

`months = ((target_date - Date.current) / 30).to_i` — maximum ~3% error vs calendar months.
Acceptable for a planning tool. Documented in code comment.

---

## ProjectionStandard

PAG 2025 canonical values from FP Canada.

```ruby
# app/models/projection_standard.rb
class ProjectionStandard < ApplicationRecord
  belongs_to :jurisdiction
  has_many :projection_assumptions, dependent: :nullify

  PAG_2025_DEFAULTS = {
    equity_return: 0.0628,           # 6.28% nominal
    fixed_income_return: 0.0409,     # 4.09% nominal
    cash_return: 0.0295,             # 2.95% nominal
    inflation_rate: 0.021,           # 2.10%
    volatility_equity: 0.18,         # 18% standard deviation
    volatility_fixed_income: 0.05,   # 5% standard deviation
    safety_margin: -0.005            # -0.50% conservative adjustment
  }.freeze

  def blended_return(equity_weight: 0.6, fixed_income_weight: 0.3, cash_weight: 0.1)
  def conservative_blended_return(...)  # blended_return + safety_margin
  def real_return(nominal_return: nil)  # (1 + rate) / (1 + inflation) - 1

  def self.pag_2025  # find_by(code: "PAG_2025")
end
```

---

## ProjectionAssumption

Per-account or family-default customizable assumptions.

```ruby
# app/models/projection_assumption.rb
class ProjectionAssumption < ApplicationRecord
  belongs_to :family
  belongs_to :account, optional: true          # nil = family default
  belongs_to :projection_standard, optional: true

  # Scopes
  scope :active, -> { where(is_active: true) }
  scope :using_pag, -> { where(use_pag_defaults: true) }
  scope :family_default, -> { where(account_id: nil) }
  scope :for_account_id, ->(account_id) { where(account_id: account_id) }

  # Effective values — delegate to ProjectionStandard when use_pag_defaults is true
  def effective_return      # conservative_blended_return (PAG) or expected_return (custom)
  def effective_inflation   # from standard or custom
  def effective_volatility  # from standard or custom

  # Factory methods
  def self.default_for(family)           # finds or creates family default
  def self.for_account(account)          # account-specific or family default fallback
  def self.create_for_account(account, overrides = {})
end
```

When `use_pag_defaults` is true, `effective_return` delegates to
`projection_standard.conservative_blended_return` (which includes the -0.5% safety margin).

Cache invalidation: `after_save :touch_associated_account` touches the account
(or first family account for family defaults) to bust controller-level cache keys.

---

## Account::ProjectionFacade

Replaces the old `Projectable` concern. Extracted to reduce Account's concern count.
Account delegates projection-related methods here via a lazy-initialized private accessor.

```ruby
# app/models/account/projection_facade.rb
class Account::ProjectionFacade
  def initialize(account)

  def adaptive_projection(years:, contribution: nil, assumption: nil)
  def forecast_accuracy(period: :all)
  def next_milestone
  def achieved_milestones
  def update_milestone_progress!
  def generate_projections!(months: 120)
  def update_milestone_projections!
  def projection_chart_data(years: 10, assumption: nil)  # {historical, projections, currency, today}
end
```

Uses `ProjectionCalculator#project_with_analytical_bands` for chart data (deterministic
bands, not Monte Carlo — faster for rendering).

---

## PagCompliant Concern

```ruby
# app/models/concerns/pag_compliant.rb
module PagCompliant
  PAG_2025_ASSUMPTIONS = { ... }  # same values as ProjectionStandard::PAG_2025_DEFAULTS

  def pag_compliant?          # checks assumption.pag_compliant?
  def pag_assumption_warnings # returns array of warning strings
  def compliance_badge        # "Using standard Canadian guidelines (conservative)" or "Using custom assumptions"
  def pag_default(key)        # lookup from PAG_2025_ASSUMPTIONS
end
```

---

## Caching Strategy

Calculators are pure — no caching inside them. Caching lives in `ProjectionsController`:

```ruby
# Controller-level caching with projection_cache_key
# Cache invalidated when:
#   - Account is touched (balance change, sync)
#   - ProjectionAssumption is saved (touch_associated_account callback)
#   - Projection params change
```

---

## Testing Patterns

Key assertions for projection tests:

```ruby
# Drift correction: p50 < mean for volatile portfolios
assert result[:p50] < result[:mean], "p50 should be less than mean (log-normal)"

# Safety margin applied
assert_in_delta PAG_2025_DEFAULTS[:safety_margin], -0.005, 0.0001

# Box-Muller guard
assert_nothing_raised { calc.project_with_percentiles(months: 1, volatility: 0.5) }

# Unreachable target returns nil
assert_nil calc.months_to_target(target: 1_000_000_000)

# Currency warnings surfaced
assert result[:currency_warnings].present? if mixed_currencies
```

Use `DebtSimulatorTestHelper` from `test/support/` for debt simulation test setup.

---

## Anti-Patterns — DO NOT

- **DO NOT** reference `Projectable` concern — it does not exist. Use `Account::ProjectionFacade`
- **DO NOT** use `0.066` as default return — actual PAG blended is `0.0628` equity, `0.0409` fixed, with `-0.005` safety margin
- **DO NOT** use scope `default_for_account` — actual scopes are `for_account_id`, `active`, `using_pag`, `family_default`
- **DO NOT** use `ProjectionStandard::PAG_2025_ASSUMPTIONS` with keys like `equity_volatility: 0.157` — actual key is `volatility_equity: 0.18`
- **DO NOT** use `rand` directly in Box-Muller — use `[rand, Float::EPSILON].max` to guard against log(0)
- **DO NOT** put caching in calculators — caching belongs in `ProjectionsController`
- **DO NOT** show p50 as mean — p50 uses drift correction `exp(-sigma^2/2)` for true log-normal median
- **DO NOT** use `rate / 12` for Canadian mortgages — that's for investments only. Mortgages use `CanadianMortgage.monthly_rate`
