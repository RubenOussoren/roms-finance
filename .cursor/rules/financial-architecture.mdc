---
description: Financial architecture — calculator/simulator patterns, jurisdiction-aware design
globs:
  - "app/calculators/**/*.rb"
  - "app/services/**/*.rb"
  - "app/models/concerns/**/*.rb"
  - "db/seeds/**/*.rb"
alwaysApply: false
---

# Financial Architecture Patterns

This rule defines core patterns for financial calculations, simulators, jurisdiction-aware design, and data structures.

---

## Part 1: Calculator Pattern

**When to use**: Any calculation with >10 lines of logic that performs pure mathematical operations.

**Characteristics**:
- Pure functions with no side effects
- No database writes or API calls
- Returns value objects or hashes
- Testable with known values
- Reusable across controllers, jobs, and services

**Structure** (Actual Implementation):
```ruby
# app/calculators/[domain]_calculator.rb
class ProjectionCalculator
  attr_reader :principal, :rate, :contribution, :currency

  def initialize(principal:, rate:, contribution: 0, currency: "CAD")
    @principal = principal.to_d
    @rate = rate.to_d
    @contribution = contribution.to_d
    @currency = currency
  end

  # Calculate future value at a specific month
  # NOTE: rate/12 is correct for investment growth projections.
  # Canadian fixed-rate mortgages use semi-annual compounding:
  #   monthly_rate = (1 + annual_rate/2)^(1/6) - 1
  # See debt-optimization.mdc for mortgage-specific formulas.
  def future_value_at_month(month)
    return principal if month <= 0
    monthly_rate = rate / 12
    if monthly_rate.zero?
      principal + (contribution * month)
    else
      compound_factor = (1 + monthly_rate) ** month
      principal * compound_factor + contribution * ((compound_factor - 1) / monthly_rate)
    end
  end

  # Generate projection data for multiple months
  def project(months:)
    (1..months).map do |month|
      {
        month: month,
        date: Date.current + month.months,
        balance: future_value_at_month(month).round(2),
        cumulative_contribution: (contribution * month).round(2),
        growth: (future_value_at_month(month) - principal - (contribution * month)).round(2)
      }
    end
  end

  # Monte Carlo with percentiles (pure Ruby implementation)
  def project_with_percentiles(months:, volatility:, simulations: 1000)
    # ... see actual implementation
  end
end
```

**Implemented Calculators**:
- `ProjectionCalculator` - Investment growth over time
- `ForecastAccuracyCalculator` - MAPE, RMSE, Tracking Signal metrics
- `MilestoneCalculator` - Financial goal timeline projections

**Testing Pattern**:
```ruby
test "compound interest calculation matches formula" do
  calc = ProjectionCalculator.new(principal: 1000, rate: 0.08, contribution: 0)
  expected = 1000 * (1.08 ** 10)
  assert_in_delta expected, calc.future_value_at_month(120), 0.01
end
```

---

## Part 2: Simulator Pattern

**When to use**: Multi-step financial simulations with complex state changes over time.

**Characteristics**:
- Models month-by-month or year-by-year scenarios
- Maintains state across time periods
- Compares multiple strategies (baseline vs optimized)
- Returns detailed ledger entries
- Used for "what-if" analysis

**Structure**:
```ruby
# app/services/[domain]_simulator.rb
class CanadianSmithManoeuvrSimulator
  def initialize(strategy)
    @strategy = strategy
    @tax_config = strategy.jurisdiction.tax_calculator_config
  end

  def run(months:)
    results = {
      baseline: simulate_baseline(months),
      modified: simulate_modified(months)
    }

    {
      baseline_total_interest: results[:baseline][:total_interest],
      modified_total_interest: results[:modified][:total_interest],
      net_savings: calculate_net_savings(results),
      month_by_month: results[:modified][:ledger]
    }
  end

  private

  def simulate_modified(months)
    ledger = []
    months.times do |month|
      entry = calculate_month_entry(month)
      validate_compliance(entry)
      check_auto_stop_rules(entry)
      ledger << entry
    end
    ledger
  end
end
```

**Implemented Simulators**:
- `CanadianSmithManoeuvrSimulator` - CRA-compliant debt optimization
- `BaselineSimulator` - Default no-optimization strategy
- `PrepayOnlySimulator` - Prepayment-only comparator

**Anti-patterns**:
- Don't put simulators in models (too complex for model logic)
- Don't mix simulator logic with calculator logic
- Don't perform database writes inside simulation loops (store results after completion)

---

## Part 3: Calculator vs Simulator Decision Guide

| | Calculator | Simulator |
|---|---|---|
| **Side effects** | None (pure) | May orchestrate side effects |
| **State** | Stateless | Maintains state over time |
| **Output** | Single value/hash | Detailed ledger/timeline |
| **Performance** | < 200ms | < 2s for 30 years |
| **Location** | `app/calculators/` | `app/services/` |

### Concern Modules for Financial Behavior

**`Projectable`** - For accounts with projections:
```ruby
module Projectable
  extend ActiveSupport::Concern

  included do
    has_many :projections, class_name: "Account::Projection", dependent: :destroy
  end

  def adaptive_projection(years:, contribution: 0)
    assumption = family&.projection_assumptions&.default_for_account(self)
    rate = assumption&.effective_return || 0.066

    calculator = ProjectionCalculator.new(
      principal: balance || 0,
      rate: rate,
      contribution: contribution,
      currency: currency
    )

    calculator.project(months: years * 12)
  end
end
```

**`PagCompliant`** - For PAG 2025 assumptions (Canadian):

`PAG_2025_ASSUMPTIONS` includes `safety_margin: -0.005` (-0.5%) applied to `blended_return`. See `investment-projections.mdc` for the full `ProjectionStandard` model.

**`DataQualityCheckable`** - Three-severity data quality warnings (error/warning/info).

### Financial Data Validation (Three Levels)

1. **Database Constraints** — hard failures for impossible data (check constraints)
2. **Model Validations** — soft failures for unusual data (ActiveRecord validates)
3. **Data Quality Warnings** — informational, never block (DataQualityCheckable concern)

### Performance Considerations

**Calculators**: Complete in < 200ms, use memoization for expensive intermediate results, avoid N+1 queries.

**Simulators**: 30-year simulations (360 iterations) in < 2s, background jobs for Monte Carlo, store only percentiles (p10, p25, p50, p75, p90).

**Cache Keys**:
```ruby
def projection_cache_key
  [
    "projection",
    account.id,
    account.updated_at.to_i,
    account.holdings.maximum(:updated_at)&.to_i,
    projection_params.hash
  ].join("-")
end
```

---

## Part 4: Multi-Jurisdiction Architecture

### Core Principle: Canadian-First, Globally-Extensible

**Primary Market**: Canadian users (80%+ of content and examples)

**Design Philosophy**: Build for Canada today, architect for global expansion tomorrow.

**Implementation Strategy**:
- Phase 1-4: Build with Canadian defaults (PAG 2025, CRA tax rules, Smith Manoeuvre)
- Phase 5+: Add US/UK/EU via configuration (no refactoring required)

### Jurisdiction Configuration Pattern

**Rule: ALL tax/compliance features MUST support jurisdictions**

**Database Schema** (REQUIRED):
```ruby
# All relevant tables have jurisdiction_id (optional, defaults to Canada)
create_table :families do |t|
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: true
end

create_table :debt_optimization_strategies do |t|
  t.references :family, null: false, foreign_key: true
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: true
  t.references :tax_calculator_config, foreign_key: true
end

create_table :projection_standards do |t|
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: false
  t.integer :standard_type  # pag_2025, cfp_board_2025, iso_guidance
  t.jsonb :asset_assumptions
end
```

### JurisdictionAware Concern

```ruby
module JurisdictionAware
  extend ActiveSupport::Concern

  def jurisdiction
    country_code = determine_country_code
    @jurisdiction ||= Jurisdiction.for_country(country_code) || Jurisdiction.default
  end

  def projection_standard
    jurisdiction&.current_projection_standard
  end

  def marginal_tax_rate(income:)
    jurisdiction&.marginal_tax_rate(income: income) || 0
  end

  def interest_deductible?
    jurisdiction&.interest_deductible? || false
  end

  def supports_smith_manoeuvre?
    jurisdiction&.supports_smith_manoeuvre? || false
  end

  private

  def determine_country_code
    return country if respond_to?(:country) && country.present?
    return family.country if respond_to?(:family) && family&.country.present?
    "CA" # Default to Canada
  end
end
```

### Tax Rules as Configuration (NEVER Hardcode)

```ruby
class TaxCalculatorConfig < ApplicationRecord
  belongs_to :jurisdiction

  # Tax brackets stored as JSONB by jurisdiction
  # Deductibility rules per jurisdiction
  # Calculate marginal_tax_rate(income:, province_or_state:) from brackets

  def marginal_tax_rate(income:, province_or_state: nil)
    federal_rate = calculate_bracket_rate(income, federal_brackets.dig("2025"))
    provincial_rate = 0

    if province_or_state && provincial_state_brackets.key?(province_or_state)
      provincial_rate = calculate_bracket_rate(
        income,
        provincial_state_brackets.dig(province_or_state, "2025")
      )
    end

    federal_rate + provincial_rate
  end
end
```

### Strategy Simulators as Pluggable Classes

```ruby
class DebtOptimizationStrategy < ApplicationRecord
  include JurisdictionAware

  # Factory pattern: return appropriate simulator class
  def simulator
    case strategy_type
    when 'modified_smith'
      CanadianSmithManoeuvrSimulator.new(self)
    when 'heloc_arbitrage'
      UsHelocArbitrageSimulator.new(self)       # Future
    when 'offset_mortgage'
      UkOffsetMortgageSimulator.new(self)       # Future
    else
      BaselineSimulator.new(self)
    end
  end

  def simulate(months:)
    simulator.run(months: months)
  end
end
```

### Anti-Patterns

**Don't hardcode tax rules**:
```ruby
# BAD
def calculate_tax_benefit(interest)
  interest * 0.45  # Hardcoded rate
end

# GOOD
def calculate_tax_benefit(interest)
  marginal_rate = tax_calculator_config.marginal_tax_rate(
    income: family.annual_income,
    province_or_state: family.province
  )
  interest * marginal_rate
end
```

**Don't check jurisdiction in every method**:
```ruby
# BAD
if jurisdiction.country_code == 'CA'
  # Canadian logic
elsif jurisdiction.country_code == 'US'
  # US logic
end

# GOOD
strategy.simulator.run(months: 360)  # Factory pattern selects correct simulator
```

### Provider Pattern Alignment

This architecture leverages the existing Provider pattern:
```ruby
# Existing pattern
Provider::Registry.get_provider(:synth)  # Market data
Provider::Registry.get_provider(:plaid)  # Bank connectivity

# Extended for jurisdictions
Jurisdiction.find_by(country_code: 'CA')
  → .projection_standard                 # PAG 2025
  → .tax_calculator_config               # CRA rules
  → .available_strategies                 # Modified Smith Manoeuvre
```

**Benefits**: Add new countries via seed data (no code changes), consistent with existing patterns, defaults to Canadian rules.

---

## References

- See `docs/architecture/design-vision.md` for detailed design philosophy
- See `debt-optimization.mdc` for debt strategy and Smith Manoeuvre specifics
- See `investment-projections.mdc` for projection features and PAG 2025
- See `testing.mdc` Part 2 for financial testing patterns
