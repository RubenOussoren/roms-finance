---
description: Financial architecture — calculator/simulator patterns, jurisdiction-aware design
globs:
  - "app/calculators/**/*.rb"
  - "app/services/**/*.rb"
  - "app/models/concerns/**/*.rb"
  - "db/seeds/**/*.rb"
alwaysApply: false
---

# Financial Architecture Patterns

This rule defines core patterns for financial calculations, simulators, jurisdiction-aware design, and data structures.

---

## Part 1: Calculator Pattern

**When to use**: Any calculation with >10 lines of logic that performs pure mathematical operations.

**Characteristics**:
- Pure functions with no side effects
- No database writes or API calls
- Returns value objects or hashes
- Testable with known values
- Reusable across controllers, jobs, and services

**Structure** (Actual Implementation):
```ruby
# app/calculators/[domain]_calculator.rb
class ProjectionCalculator
  attr_reader :principal, :rate, :contribution, :currency

  def initialize(principal:, rate:, contribution: 0, currency: "CAD")
    @principal = principal.to_d
    @rate = rate.to_d
    @contribution = contribution.to_d
    @currency = currency
  end

  # Calculate future value at a specific month
  # NOTE: rate/12 is correct for investment growth projections.
  # Canadian fixed-rate mortgages use semi-annual compounding:
  #   monthly_rate = (1 + annual_rate/2)^(1/6) - 1
  # See debt-optimization.mdc for mortgage-specific formulas.
  def future_value_at_month(month)
    return principal if month <= 0
    monthly_rate = rate / 12
    if monthly_rate.zero?
      principal + (contribution * month)
    else
      compound_factor = (1 + monthly_rate) ** month
      principal * compound_factor + contribution * ((compound_factor - 1) / monthly_rate)
    end
  end

  # Generate projection data for multiple months
  def project(months:)
    (1..months).map do |month|
      {
        month: month,
        date: Date.current + month.months,
        balance: future_value_at_month(month).round(2),
        cumulative_contribution: (contribution * month).round(2),
        growth: (future_value_at_month(month) - principal - (contribution * month)).round(2)
      }
    end
  end

  # Monte Carlo with percentiles (pure Ruby implementation)
  def project_with_percentiles(months:, volatility:, simulations: 1000)
    # ... see actual implementation
  end
end
```

**Implemented Calculators**:
- `ProjectionCalculator` - Investment growth over time
- `ForecastAccuracyCalculator` - MAPE, RMSE, Tracking Signal metrics
- `MilestoneCalculator` - Financial goal timeline projections

**Testing Pattern**:
```ruby
test "compound interest calculation matches formula" do
  calc = ProjectionCalculator.new(principal: 1000, rate: 0.08, contribution: 0)
  expected = 1000 * (1.08 ** 10)
  assert_in_delta expected, calc.future_value_at_month(120), 0.01
end
```

---

## Part 2: Simulator Pattern

**When to use**: Multi-step financial simulations with complex state changes over time.

**Characteristics**:
- Models month-by-month or year-by-year scenarios
- Maintains state across time periods
- Compares multiple strategies (baseline vs optimized)
- Returns detailed ledger entries
- Used for "what-if" analysis

**Structure**:

All debt simulators inherit from `AbstractDebtSimulator` (template method pattern) or reuse its concerns:

```ruby
# app/services/abstract_debt_simulator.rb
class AbstractDebtSimulator
  include MortgageRenewalSupport
  include LoanTermDefaults

  def initialize(strategy)
    @strategy = strategy
  end

  def simulate!  # Entry point — no arguments
    # Template method: builds ledger entries month-by-month
  end
end
```

Subclasses override `scenario_type` and `calculate_prepayment` to control behavior. The Smith simulator keeps its own loop (HELOC/readvanceable logic is too different) but reuses `MortgageRenewalSupport`.

**Implemented Simulators**:
- `AbstractDebtSimulator` - Base class with template method pattern
- `BaselineSimulator < AbstractDebtSimulator` - Default no-optimization strategy
- `PrepayOnlySimulator < AbstractDebtSimulator` - Prepayment-only comparator
- `CanadianSmithManoeuvrSimulator` - CRA-compliant debt optimization (own loop, includes `MortgageRenewalSupport`)

**Anti-patterns**:
- Don't put simulators in models (too complex for model logic)
- Don't mix simulator logic with calculator logic
- Don't perform database writes inside simulation loops (store results after completion)

---

## Part 3: Calculator vs Simulator Decision Guide

| | Calculator | Simulator |
|---|---|---|
| **Side effects** | None (pure) | May orchestrate side effects |
| **State** | Stateless | Maintains state over time |
| **Output** | Single value/hash | Detailed ledger/timeline |
| **Performance** | < 200ms | < 2s for 30 years |
| **Location** | `app/calculators/` | `app/services/` |

### Concern Modules for Financial Behavior

**`PagCompliant`** - For PAG 2025 assumptions (Canadian):

`PAG_2025_ASSUMPTIONS` includes `safety_margin: -0.005` (-0.5%) applied to `blended_return`. See `investment-projections.mdc` for the full `ProjectionStandard` model.

**`DataQualityCheckable`** - Three-severity data quality warnings (error/warning/info).

### Financial Data Validation (Three Levels)

1. **Database Constraints** — hard failures for impossible data (check constraints)
2. **Model Validations** — soft failures for unusual data (ActiveRecord validates)
3. **Data Quality Warnings** — informational, never block (DataQualityCheckable concern)

### Performance Considerations

**Calculators**: Complete in < 200ms, use memoization for expensive intermediate results, avoid N+1 queries.

**Simulators**: 30-year simulations (360 iterations) in < 2s, background jobs for Monte Carlo, store only percentiles (p10, p25, p50, p75, p90).

**Cache Keys**:
```ruby
def projection_cache_key
  [
    "projection",
    account.id,
    account.updated_at.to_i,
    account.holdings.maximum(:updated_at)&.to_i,
    projection_params.hash
  ].join("-")
end
```

---

## Part 4: Multi-Jurisdiction Architecture

### Core Principle: Canadian-First, Globally-Extensible

**Primary Market**: Canadian users (80%+ of content and examples)

**Design Philosophy**: Build for Canada today, architect for global expansion tomorrow.

**Implementation Strategy**:
- Phase 1-4: Build with Canadian defaults (PAG 2025, CRA tax rules, Smith Manoeuvre)
- Phase 5+: Add US/UK/EU via configuration (no refactoring required)

### Jurisdiction Configuration Pattern

**Rule: ALL tax/compliance features MUST support jurisdictions**

**Database Schema** (REQUIRED):
```ruby
# All relevant tables have jurisdiction_id (optional, defaults to Canada)
create_table :families do |t|
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: true
end

create_table :debt_optimization_strategies do |t|
  t.references :family, null: false, foreign_key: true
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: true
end

create_table :projection_standards do |t|
  t.references :jurisdiction, type: :uuid, foreign_key: true, null: false
  t.integer :standard_type  # pag_2025, cfp_board_2025, iso_guidance
  t.jsonb :asset_assumptions
end
```

### JurisdictionAware Concern

```ruby
module JurisdictionAware
  extend ActiveSupport::Concern

  def jurisdiction
    country_code = determine_country_code
    @jurisdiction ||= Jurisdiction.for_country(country_code) || Jurisdiction.default
  end

  def projection_standard
    jurisdiction&.current_projection_standard
  end

  def marginal_tax_rate(income:)
    jurisdiction&.marginal_tax_rate(income: income) || 0
  end

  def interest_deductible?
    jurisdiction&.interest_deductible? || false
  end

  def supports_smith_manoeuvre?
    jurisdiction&.supports_smith_manoeuvre? || false
  end

  private

  def determine_country_code
    return country if respond_to?(:country) && country.present?
    return family.country if respond_to?(:family) && family&.country.present?
    "CA" # Default to Canada
  end
end
```

### Tax Rules as Configuration (NEVER Hardcode)

Tax calculations are provided by the `JurisdictionAware` concern — there is no separate `TaxCalculatorConfig` AR model. The `Jurisdiction` model stores tax brackets in its `tax_config` JSONB column and provides `marginal_tax_rate(income:)` directly:

```ruby
# Use via JurisdictionAware concern
marginal_tax_rate(income: family.annual_income)
# → Combines federal + provincial brackets from Jurisdiction#tax_config
```

### Strategy Simulators as Pluggable Classes

```ruby
class DebtOptimizationStrategy < ApplicationRecord
  include JurisdictionAware

  # Factory pattern: return appropriate simulator class
  def simulator
    case strategy_type
    when 'modified_smith'
      CanadianSmithManoeuvrSimulator.new(self)
    when 'heloc_arbitrage'
      UsHelocArbitrageSimulator.new(self)       # Future
    when 'offset_mortgage'
      UkOffsetMortgageSimulator.new(self)       # Future
    else
      BaselineSimulator.new(self)
    end
  end

  def run_simulation!
    simulator.simulate!
  end
end
```

### Anti-Patterns

**Don't hardcode tax rules**:
```ruby
# BAD
def calculate_tax_benefit(interest)
  interest * 0.45  # Hardcoded rate
end

# GOOD
def calculate_tax_benefit(interest)
  interest * marginal_tax_rate(income: family.annual_income)
end
```

**Don't check jurisdiction in every method**:
```ruby
# BAD
if jurisdiction.country_code == 'CA'
  # Canadian logic
elsif jurisdiction.country_code == 'US'
  # US logic
end

# GOOD
strategy.simulator.simulate!  # Factory pattern selects correct simulator
```

### Provider Pattern Alignment

This architecture leverages the existing Provider pattern:
```ruby
# Existing pattern
Provider::Registry.get_provider(:market_data_provider)  # Market data (Alpha Vantage)
Provider::Registry.get_provider(:plaid)  # Bank connectivity

# Extended for jurisdictions
Jurisdiction.find_by(country_code: 'CA')
  → .projection_standard                 # PAG 2025
  → .tax_config                          # CRA rules (JSONB on Jurisdiction)
  → .available_strategies                 # Modified Smith Manoeuvre
```

**Benefits**: Add new countries via seed data (no code changes), consistent with existing patterns, defaults to Canadian rules.

---

## References

- See `docs/architecture/design-vision.md` for detailed design philosophy
- See `debt-optimization.mdc` for debt strategy and Smith Manoeuvre specifics
- See `investment-projections.mdc` for projection features and PAG 2025
- See `testing.mdc` Part 2 for financial testing patterns
