---
description: Frontend conventions — ViewComponents, Stimulus controllers, UI/UX design, and design system tokens
globs:
  - "app/views/**/*"
  - "app/components/**/*"
  - "app/javascript/**/*"
  - "app/assets/**/*"
alwaysApply: false
---

# Frontend Conventions

This rule covers ViewComponent patterns, Stimulus controller conventions, and UI/UX design guidelines.

---

## Part 1: ViewComponent Patterns

### Component vs. Partial Decision Making

- **Use ViewComponents when:**
  - Element has complex logic or styling patterns
  - Element will be reused across multiple views/contexts
  - Element needs structured styling with variants/sizes (like buttons, badges)
  - Element requires interactive behavior or Stimulus controllers
  - Element has configurable slots or complex APIs
  - Element needs accessibility features or ARIA support

- **Use Partials when:**
  - Element is primarily static HTML with minimal logic
  - Element is used in only one or few specific contexts
  - Element is simple template content (like CTAs, static sections)
  - Element doesn't need variants, sizes, or complex configuration
  - Element is more about content organization than reusable functionality

### Prefer Components Over Partials

- If there is a component available for the use case in app/components, use it
- If there is no component, look for a partial
- If there is no partial, decide between component or partial based on the criteria above

### Examples of Component vs. Partial Usage

```erb
<%# Component: Complex, reusable with variants and interactivity %>
<%= render DialogComponent.new(variant: :drawer) do |dialog| %>
  <% dialog.with_header(title: "Account Settings") %>
  <% dialog.with_body { "Dialog content here" } %>
<% end %>

<%# Component: Interactive with complex styling options %>
<%= render ButtonComponent.new(text: "Save Changes", variant: "primary", confirm: "Are you sure?") %>

<%# Component: Reusable with variants %>
<%= render FilledIconComponent.new(icon: "credit-card", variant: :surface) %>

<%# Partial: Static template content %>
<%= render "shared/logo" %>

<%# Partial: Simple, context-specific content with basic styling %>
<%= render "shared/trend_change", trend: @account.trend, comparison_label: "vs last month" %>

<%# Partial: Simple divider/utility %>
<%= render "shared/ruler", classes: "my-4" %>

<%# Partial: Simple form utility %>
<%= render "shared/form_errors", model: @account %>
```

### Keep Domain Logic Out of Views

```erb
<%# BAD!!! %>
<% button_classes = { class: "bg-blue-500 hover:bg-blue-600" } %>
<%= tag.button class: button_classes do %>
  Save Account
<% end %>

<%# GOOD! %>
<%= tag.button class: computed_button_classes do %>
  Save Account
<% end %>
```

### Naming Conventions

- **Components**: Use `ComponentName` suffix (e.g., `ButtonComponent`, `DialogComponent`, `FilledIconComponent`)
- **Partials**: Use underscore prefix (e.g., `_trend_change.html.erb`, `_form_errors.html.erb`)
- **Shared partials**: Place in `app/views/shared/` directory for reusable content
- **Context-specific partials**: Place in relevant controller view directory

---

## Part 2: Stimulus Controller Conventions

### Use Declarative Actions, Not Imperative Event Listeners

Instead of assigning a Stimulus target and binding it to an event listener in the initializer, always write Controllers + ERB views declaratively by using Stimulus actions in ERB to call methods in the Stimulus JS controller.

BAD code:

```js
// BAD!!!! DO NOT DO THIS!!
// Imperative - controller does all the work
export default class extends Controller {
  static targets = ["button", "content"]

  connect() {
    this.buttonTarget.addEventListener("click", this.toggle.bind(this))
  }

  toggle() {
    this.contentTarget.classList.toggle("hidden")
    this.buttonTarget.textContent = this.contentTarget.classList.contains("hidden") ? "Show" : "Hide"
  }
}
```

GOOD code:

```erb
<!-- Declarative - HTML declares what happens -->
<div data-controller="toggle">
  <button data-action="click->toggle#toggle" data-toggle-target="button">Show</button>
  <div data-toggle-target="content" class="hidden">Hello World!</div>
</div>
```

```js
// Declarative - controller just responds
export default class extends Controller {
  static targets = ["button", "content"]

  toggle() {
    this.contentTarget.classList.toggle("hidden")
    this.buttonTarget.textContent = this.contentTarget.classList.contains("hidden") ? "Show" : "Hide"
  }
}
```

### Keep Stimulus Controllers Lightweight

- Always aim for less than 7 controller targets. Any more is a sign of too much complexity.
- Use private methods and expose a clear public API

### Keep Stimulus Controllers Focused

- Domain logic does NOT belong in a Stimulus controller
- Stimulus controllers should aim for a single responsibility, or a group of highly related responsibilities
- Make good use of Stimulus's callbacks, actions, targets, values, and classes

### Component Controllers Must Stay in Component

- If a Stimulus controller is in the `app/components` directory, it should only be used in its component view. It should not be used anywhere in `app/views`.

### Stimulus Integration in Views

- Always use the **declarative approach** when integrating Stimulus controllers
- The ERB template should declare what happens, the Stimulus controller should respond
- Pass data from Rails to Stimulus using `data-*-value` attributes, not inline JavaScript
- Use Stimulus targets to reference DOM elements, not manual `getElementById` calls

### Stimulus Controller Placement

- **Component controllers** (in `app/components/`) — only within their component templates
- **Global controllers** (in `app/javascript/controllers/`) — can be used across any view

---

## Part 3: UI/UX Design Guidelines

### Design System

The codebase uses TailwindCSS v4.x with a custom design system defined in [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css).

### Rules (Mandatory)

- Always start by referencing [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css) to see the base primitives, functional tokens, and component tokens
- Always prefer using the functional "tokens" defined in maybe-design-system.css when possible:
  - Use `text-primary` rather than `text-white`
  - Use `bg-container` rather than `bg-white`
  - Use `border border-primary` rather than `border border-gray-200`
- Never create new styles in [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css) or [application.css](mdc:app/assets/tailwind/application.css) without explicitly receiving permission to do so
- Always generate semantic HTML
- Always use `icon` helper, never `lucide_icon` directly

---

## Part 4: Turbo Frame & Stream Conventions

### Turbo Frames

Use `turbo_frame_tag` to define replaceable page sections. Frames enable partial page updates without full reloads.

```erb
<%# Wrap content in a frame for lazy loading or inline editing %>
<%= turbo_frame_tag dom_id(account, :holdings), src: holdings_path(account_id: account.id) do %>
  Loading holdings...
<% end %>

<%# Modal pattern: wrap modal content in a "modal" frame %>
<%= turbo_frame_tag "modal" do %>
  <dialog>...</dialog>
<% end %>
```

**Conventions**:
- Use `dom_id(model)` or `dom_id(model, :prefix)` for frame IDs
- Use `src:` attribute for lazy-loaded frames
- Use `turbo_frame_tag "modal"` for all modal/drawer content

### Turbo Streams

Use `.turbo_stream.erb` templates for multi-element updates from a single action.

```erb
<%# app/views/transfers/update.turbo_stream.erb %>
<%= turbo_stream.replace @transfer.inflow_transaction.entry %>
<%= turbo_stream.replace dom_id(@budget, :allocation_progress),
    partial: "budget_categories/allocation_progress",
    locals: { budget: @budget } %>
```

**Conventions**:
- Prefer `turbo_stream.replace` for updating existing content
- Use `turbo_stream.update` for replacing inner HTML only
- Always use `dom_id` helpers for consistent target IDs

---

## Part 5: ViewComponent Slot API

Components use `renders_one` and `renders_many` to define composable content slots.

### DS (Design System) Components

DS components inherit from `DesignSystemComponent` and provide reusable UI primitives:

```ruby
# app/components/DS/dialog.rb
class DS::Dialog < DesignSystemComponent
  renders_one :header, ->(title: nil, subtitle: nil, hide_close_icon: false, **opts, &block) do
    # ...
  end
  renders_one :body
  renders_many :actions, ->(cancel_action: false, **button_opts) do
    # ...
  end
  renders_many :sections, ->(title:, **disclosure_opts, &block) do
    # ...
  end
end
```

### UI (Business) Components

UI components inherit from `ApplicationComponent` and encapsulate domain-specific UI:

```ruby
# app/components/UI/account_page.rb
class UI::AccountPage < ApplicationComponent
  renders_one :activity_feed, ->(feed_data:, pagy:, search:) {
    UI::Account::ActivityFeed.new(feed_data: feed_data, pagy: pagy, search: search)
  }
  renders_one :milestone_tracker, -> {
    UI::Account::MilestoneTracker.new(account: account)
  }
end
```

### Using Slots in Templates

```erb
<%= render DS::Dialog.new(variant: :drawer) do |dialog| %>
  <% dialog.with_header(title: "Account Settings") %>
  <% dialog.with_body do %>
    Dialog content here
  <% end %>
  <% dialog.with_action(variant: "primary") { "Save" } %>
<% end %>
```

**Conventions**:
- `DS::*` components: design primitives (buttons, dialogs, menus, tabs, alerts)
- `UI::*` components: business-specific (account pages, projections, debt optimization)
- Use lambda slots (`->()`) when the slot needs to instantiate another component
- Use block slots for simple content injection
