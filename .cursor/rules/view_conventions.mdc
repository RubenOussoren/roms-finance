---
description: Frontend conventions — ViewComponents, Stimulus controllers, UI/UX design, and design system tokens
globs:
  - "app/views/**/*"
  - "app/components/**/*"
  - "app/javascript/**/*"
  - "app/assets/**/*"
alwaysApply: false
---

# Frontend Conventions

This rule covers ViewComponent patterns, Stimulus controller conventions, and UI/UX design guidelines.

---

## Part 1: ViewComponent Patterns

### Component vs. Partial Decision Making

- **Use ViewComponents when:**
  - Element has complex logic or styling patterns
  - Element will be reused across multiple views/contexts
  - Element needs structured styling with variants/sizes (like buttons, badges)
  - Element requires interactive behavior or Stimulus controllers
  - Element has configurable slots or complex APIs
  - Element needs accessibility features or ARIA support

- **Use Partials when:**
  - Element is primarily static HTML with minimal logic
  - Element is used in only one or few specific contexts
  - Element is simple template content (like CTAs, static sections)
  - Element doesn't need variants, sizes, or complex configuration
  - Element is more about content organization than reusable functionality

### Prefer Components Over Partials

- If there is a component available for the use case in app/components, use it
- If there is no component, look for a partial
- If there is no partial, decide between component or partial based on the criteria above

### Examples of Component vs. Partial Usage

```erb
<%# Component: Complex, reusable with variants and interactivity %>
<%= render DialogComponent.new(variant: :drawer) do |dialog| %>
  <% dialog.with_header(title: "Account Settings") %>
  <% dialog.with_body { "Dialog content here" } %>
<% end %>

<%# Component: Interactive with complex styling options %>
<%= render ButtonComponent.new(text: "Save Changes", variant: "primary", confirm: "Are you sure?") %>

<%# Component: Reusable with variants %>
<%= render FilledIconComponent.new(icon: "credit-card", variant: :surface) %>

<%# Partial: Static template content %>
<%= render "shared/logo" %>

<%# Partial: Simple, context-specific content with basic styling %>
<%= render "shared/trend_change", trend: @account.trend, comparison_label: "vs last month" %>

<%# Partial: Simple divider/utility %>
<%= render "shared/ruler", classes: "my-4" %>

<%# Partial: Simple form utility %>
<%= render "shared/form_errors", model: @account %>
```

### Keep Domain Logic Out of Views

```erb
<%# BAD!!! %>
<% button_classes = { class: "bg-blue-500 hover:bg-blue-600" } %>
<%= tag.button class: button_classes do %>
  Save Account
<% end %>

<%# GOOD! %>
<%= tag.button class: computed_button_classes do %>
  Save Account
<% end %>
```

### Naming Conventions

- **Components**: Use `ComponentName` suffix (e.g., `ButtonComponent`, `DialogComponent`, `FilledIconComponent`)
- **Partials**: Use underscore prefix (e.g., `_trend_change.html.erb`, `_form_errors.html.erb`)
- **Shared partials**: Place in `app/views/shared/` directory for reusable content
- **Context-specific partials**: Place in relevant controller view directory

---

## Part 2: Stimulus Controller Conventions

### Use Declarative Actions, Not Imperative Event Listeners

Instead of assigning a Stimulus target and binding it to an event listener in the initializer, always write Controllers + ERB views declaratively by using Stimulus actions in ERB to call methods in the Stimulus JS controller.

BAD code:

```js
// BAD!!!! DO NOT DO THIS!!
// Imperative - controller does all the work
export default class extends Controller {
  static targets = ["button", "content"]

  connect() {
    this.buttonTarget.addEventListener("click", this.toggle.bind(this))
  }

  toggle() {
    this.contentTarget.classList.toggle("hidden")
    this.buttonTarget.textContent = this.contentTarget.classList.contains("hidden") ? "Show" : "Hide"
  }
}
```

GOOD code:

```erb
<!-- Declarative - HTML declares what happens -->
<div data-controller="toggle">
  <button data-action="click->toggle#toggle" data-toggle-target="button">Show</button>
  <div data-toggle-target="content" class="hidden">Hello World!</div>
</div>
```

```js
// Declarative - controller just responds
export default class extends Controller {
  static targets = ["button", "content"]

  toggle() {
    this.contentTarget.classList.toggle("hidden")
    this.buttonTarget.textContent = this.contentTarget.classList.contains("hidden") ? "Show" : "Hide"
  }
}
```

### Keep Stimulus Controllers Lightweight

- Always aim for less than 7 controller targets. Any more is a sign of too much complexity.
- Use private methods and expose a clear public API

### Keep Stimulus Controllers Focused

- Domain logic does NOT belong in a Stimulus controller
- Stimulus controllers should aim for a single responsibility, or a group of highly related responsibilities
- Make good use of Stimulus's callbacks, actions, targets, values, and classes

### Component Controllers Must Stay in Component

- If a Stimulus controller is in the `app/components` directory, it should only be used in its component view. It should not be used anywhere in `app/views`.

### Stimulus Integration in Views

- Always use the **declarative approach** when integrating Stimulus controllers
- The ERB template should declare what happens, the Stimulus controller should respond
- Pass data from Rails to Stimulus using `data-*-value` attributes, not inline JavaScript
- Use Stimulus targets to reference DOM elements, not manual `getElementById` calls

### Stimulus Controller Placement

- **Component controllers** (in `app/components/`) — only within their component templates
- **Global controllers** (in `app/javascript/controllers/`) — can be used across any view

---

## Part 3: UI/UX Design Guidelines

### Design System

The codebase uses TailwindCSS v4.x with a custom design system defined in [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css).

### Rules (Mandatory)

- Always start by referencing [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css) to see the base primitives, functional tokens, and component tokens
- Always prefer using the functional "tokens" defined in maybe-design-system.css when possible:
  - Use `text-primary` rather than `text-white`
  - Use `bg-container` rather than `bg-white`
  - Use `border border-primary` rather than `border border-gray-200`
- Never create new styles in [maybe-design-system.css](mdc:app/assets/tailwind/maybe-design-system.css) or [application.css](mdc:app/assets/tailwind/application.css) without explicitly receiving permission to do so
- Always generate semantic HTML
- Always use `icon` helper, never `lucide_icon` directly
